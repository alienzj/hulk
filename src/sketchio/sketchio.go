// Package sketchio is used to read and write HULK sketches
package sketchio

import (
	"encoding/json"
	"fmt"
	"io/ioutil"

	"github.com/will-rowe/hulk/src/distances"
	"github.com/will-rowe/hulk/src/helpers"
	"github.com/will-rowe/hulk/src/histosketch"
	"github.com/will-rowe/hulk/src/minhash"
	"github.com/will-rowe/hulk/src/version"
)

// AvailAlgorithms is a list of the sketching algorithms currently used by HULK
var AvailAlgorithms = []string{"histosketch", "kmv", "khf"}

// HULKdata holds the common information required by any sketching algorithm in this library
type HULKdata struct {
	Class      string       `json:"class"`
	FileName   string       `json:"filename"`
	HashFunc   string       `json:"hash_function"`
	License    string       `json:"license"`
	Signatures []*Signature `json:"signatures"`
	Version    string       `json:"version"`
	Banner     string       `json:"banner_label"` // TODO: this entry is to store a label for BANNER (e.g. for training a classifier) - let's change it to a more generic metadata label
}

// Signature contains the sketch and the algorithm by which it was generated
type Signature struct {
	Algorithm string
	Sketch    SketchObject
}

// SketchObject is an interface to process any of the sketches produced by HULK
type SketchObject interface {
	GetAlgo() string
	GetSketch() []uint64
	GetMD5() string
	SetMD5()
}

// NewHULKdata is the constructor function
func NewHULKdata() *HULKdata {
	return &HULKdata{
		Class:      "hulk_sketch",
		HashFunc:   "ntHash",
		License:    "CC0",
		Signatures: []*Signature{},
		Version:    version.VERSION,
	}
}

// Add is a method to add a sketch to the HULKdata
func (HULKdata *HULKdata) Add(inputSketch SketchObject) error {

	// check there is a sketch (this also sorts the KMV sketch)
	if len(inputSketch.GetSketch()) == 0 {
		return fmt.Errorf("no sketch was generated by the %v algorithm", inputSketch.GetAlgo())
	}

	// calculate the MD5 for the sketch and set it
	inputSketch.SetMD5()

	// create the signature struct
	sig := &Signature{
		Algorithm: inputSketch.GetAlgo(),
		Sketch:    inputSketch,
	}

	// add the sketch to the HULKdata
	HULKdata.Signatures = append(HULKdata.Signatures, sig)
	return nil
}

// WriteJSON writes a HULKdata to a JSON file on disk
func (HULKdata *HULKdata) WriteJSON(fileName string) error {

	// Make sure it isn't an empty sketch object
	if len(HULKdata.Signatures) == 0 {
		return fmt.Errorf("no sketches have been added to the JSON object yet")
	}

	// TODO: check the filename?
	HULKdata.FileName = fileName

	// Marshall it
	jsonData, err := json.MarshalIndent(HULKdata, "", "    ")
	if err != nil {
		return fmt.Errorf("error marshalling to JSON: %v", err)
	}

	// Write it
	err = ioutil.WriteFile(HULKdata.FileName, jsonData, 0644)
	if err != nil {
		return fmt.Errorf("error writing JSON to file: %v", err)
	}
	return nil
}

// LoadHULKdata loads a JSON file from disk into a HULKdata
func LoadHULKdata(fileName string) (*HULKdata, error) {

	// check the file exists
	if err := helpers.CheckFile(fileName); err != nil {
		return nil, err
	}

	// read in the file
	data, err := ioutil.ReadFile(fileName)
	if err != nil {
		return nil, err
	}

	// unmarshal JSON to an interface
	var result map[string]interface{}
	json.Unmarshal(data, &result)

	// grab the easy stuff
	loadedData := &HULKdata{
		Class:      result["class"].(string),
		FileName:   result["filename"].(string),
		HashFunc:   result["hash_function"].(string),
		Signatures: []*Signature{},
		License:    result["license"].(string),
		Version:    result["version"].(string),
		Banner:     result["banner_label"].(string),
	}

	// get the signatures
	jsonData := result["signatures"].([]interface{})
	for _, sigData := range jsonData {

		// get an empty Signature ready
		sig := Signature{}

		// get the algorithm
		sigJSONdata := sigData.(map[string]interface{})
		algoType := sigJSONdata["Algorithm"].(string)
		sig.Algorithm = algoType

		// get the sketch marshalled and then type assert
		sketchData := sigJSONdata["Sketch"].(map[string]interface{})
		sketchBytes, err := json.Marshal(sketchData)
		if err != nil {
			return nil, err
		}
		switch sig.Algorithm {
		default:
			return nil, fmt.Errorf("unknown sketching algorithm: %v", sig.Algorithm)
		case "histosketch":
			loadingSketch := &histosketch.HistoSketch{}
			json.Unmarshal(sketchBytes, loadingSketch)
			sig.Sketch = loadingSketch
		case "kmv":
			loadingSketch := &minhash.KMVsketch{}
			json.Unmarshal(sketchBytes, loadingSketch)
			sig.Sketch = loadingSketch
		case "khf":
			loadingSketch := &minhash.KHFsketch{}
			json.Unmarshal(sketchBytes, loadingSketch)
			sig.Sketch = loadingSketch
		}

		// add the populate Signature to the slice
		loadedData.Signatures = append(loadedData.Signatures, &sig)
	}

	// check that the loaded data is okay to use
	if len(loadedData.Signatures) < 1 {
		return nil, fmt.Errorf("no signatures found in supplied file: %v\n", fileName)
	}
	if loadedData.FileName != fileName {
		return nil, fmt.Errorf("filename mismatch: %v vs. %v\n", loadedData.FileName, fileName)
	}
	if loadedData.Class != "hulk_sketch" {
		return nil, fmt.Errorf("JSON not created by HULK: %v\n", fileName)
	}
	if loadedData.Version != version.VERSION {
		return nil, fmt.Errorf("the loaded sketch was created with a different version of HULK: %v\n", loadedData.Version)
	}
	for _, sig := range loadedData.Signatures {

		// get the stored MD5
		storedMD5 := sig.Sketch.GetMD5()
		if storedMD5 == "" {
			return nil, fmt.Errorf("no MD5 was stored for a sketch: %v\n", loadedData.FileName)
		}

		// calculate a new MD5
		sig.Sketch.SetMD5()
		newMD5 := sig.Sketch.GetMD5()

		// check they match
		if storedMD5 != newMD5 {
			return nil, fmt.Errorf("md5sum mismatch: %v vs. %v\n", storedMD5, newMD5)
		}
	}
	return loadedData, nil
}

// FindSketch is a method to return a single sketch object from a HULKdata, derived from a specified kmer size and sketching algorithm
func (HULKdata *HULKdata) FindSketch(kSize uint, algo string) (SketchObject, error) {

	// check that the specified algo is used by HULK
	algoCheck := false
	for _, supported := range AvailAlgorithms {
		if algo == supported {
			algoCheck = true
		}
	}
	if !algoCheck {
		return nil, fmt.Errorf("specified algorithm (%v) not found in the supplied sketch: %v\n", algo, HULKdata.FileName)
	}

	// find the signatures with the requested algorithm
	sigs := []*Signature{}
	for _, sig := range HULKdata.Signatures {
		if sig.Algorithm == algo {
			sigs = append(sigs, sig)
		}
	}
	if len(sigs) < 1 {
		return nil, fmt.Errorf("no sketches were produced using the %v algorithm in file: %v\n", algo, HULKdata.FileName)
	}

	// find the correct k-mer size
	sketchObjs := []SketchObject{}
	for _, sig := range sigs {
		switch sig.Algorithm {
		default:
			return nil, fmt.Errorf("unsupported sketching algorithm: %v\n", algo)
		case "histosketch":
			var x *histosketch.HistoSketch = sig.Sketch.(*histosketch.HistoSketch)
			if x.KmerSize == kSize {
				sketchObjs = append(sketchObjs, sig.Sketch)
			}
		case "kmv":
			var x *minhash.KMVsketch = sig.Sketch.(*minhash.KMVsketch)
			if x.KmerSize == kSize {
				sketchObjs = append(sketchObjs, sig.Sketch)
			}
		case "khf":
			var x *minhash.KHFsketch = sig.Sketch.(*minhash.KHFsketch)
			if x.KmerSize == kSize {
				sketchObjs = append(sketchObjs, sig.Sketch)
			}
		}
	}

	// there shouldn't be more than one sketch with the requested algorithm and k-mer size
	if len(sketchObjs) > 1 {
		return nil, fmt.Errorf("found %d possible duplicate sketches in the supplied sketch file: %v\n", len(sketchObjs), HULKdata.FileName)
	}

	// there might be no sketches in this file with the supplied k-mer size
	if len(sketchObjs) == 0 {
		return nil, fmt.Errorf("specified k-mer size (%d) not found in the supplied sketch file: %v\n", kSize, HULKdata.FileName)
	}
	return sketchObjs[0], nil
}

// GetDistance is a method to calculate a distance metric for two sketch objects
func (HULKdata *HULKdata) GetDistance(query *HULKdata, metric string, kSize uint, algo string) (float64, error) {

	// get the sketch objects of requested kSize
	subjectSketchObj, err := HULKdata.FindSketch(kSize, algo)
	if err != nil {
		return 0.0, err
	}
	querySketchObj, err := query.FindSketch(kSize, algo)
	if err != nil {
		return 0.0, err
	}
	subjectSketch := subjectSketchObj.GetSketch()
	querySketch := querySketchObj.GetSketch()

	// check the sketch sizes match
	if len(subjectSketch) != len(querySketch) {
		return 0.0, fmt.Errorf("sketch length mismatch: %d vs %d\n", len(subjectSketch), len(querySketch))
	}

	// convert sketches to float64s
	setA := make([]float64, len(subjectSketch))
	setB := make([]float64, len(querySketch))
	for i := 0; i < len(setA); i++ {
		setA[i] = float64(subjectSketch[i])
		setB[i] = float64(querySketch[i])
	}

	// run the distance calculation
	if metric == "weightedjaccard" {

		// only supported by histosketches at the moment
		var hsA *histosketch.HistoSketch
		var hsB *histosketch.HistoSketch
		var ok bool
		if hsA, ok = subjectSketchObj.(*histosketch.HistoSketch); !ok {
			return 0.0, fmt.Errorf("weighted jaccard is only supported for histosketches")
		}
		if hsB, ok = subjectSketchObj.(*histosketch.HistoSketch); !ok {
			return 0.0, fmt.Errorf("weighted jaccard is only supported for histosketches")
		}

		// get the weights and calculate the distance
		return distances.GetWJD(setA, setB, hsA.SketchWeights, hsB.SketchWeights)
	}

	// calculate the distance
	return distances.GetDistance(setA, setB, metric)
}
